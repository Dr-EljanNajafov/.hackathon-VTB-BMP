## Документация к API находится по пути ```/docs```

(ручки также можно подергать через swagger)
### Описание алгоритма
/*
    * [1] Правилом для радиуса (около пользователя) является некоторый набор величин,
    * отражающие длину в километрах, согласно которым алгоритм будет рекурсивно
    * исполняться, используя новые параметры радиуса
    *
    * [2] Правило, которое связывает фильтры функционирования отделения банка
    * (время работы), предполагает некоторый набор величин, отражающие длину
    * в километрах, согласно которым можно выделить закономерность в росте
    * вероятности закрытых отделений, чтобы в дальнейшем предположить
    * вероятностное нерабочее состояние всех отеделений в регионе
    *
    * [3] Правило загруженности определяет приоритет загруженности, иначе говоря,
    * максимально допустимая степень загруженности отделения. Состоит из статичного
    * списка степеней загруженности: FREE, NORMAL, MEDIUM, HEAVY
    *
    * [4] Правило приоритета отдаленности и занятости. Отделение, имеющее наименьшие
    * показатели отдаленности и занятости среди других рассматриваемых отделений,
    * априори является результирующим отделением. Если такого отделения не нашлось,
    * тогда рассматривается отделения, у которых только один из показателей является
    * наименьшим или лидирующим, а также отделение с наихудшими показателями, иначе
    * говоря, все остальных отделения. Для каждого из таких отделений высчитывается
    * коэффициент, приоритетным отделением является отделение с наименьшим показателем
    * коэффициента.
    * Входные данные:
    *   Отдаленность (расстояние) {distance} - число - величина в километрах
    *   Занятость (загруженность) {workload} - число - соответствие степеням загруженности:
    *       FREE - 1, NORMAL - 2, MEDIUM - 3, HEAVY - 4
    *   5 - число - количество степеней загруженности плюс один
    * Математическая формула рассчета коэффициента:
    *   k = distance / (5 - workload)
    * Датасет правдивости (radius 5km; max d=5km):
    *     d  |  w  |  k
    *     1     1    0.25
    *     1     2    0.33
    *     1     3    0.5
    *     1     4     1
    *     2     1    0.5
    *     2     2    0.6
    *     2     3     1
    *     2     4     2
    *     3     1    0.75
    *     3     2     1
    *     3     3    1.5
    *     3     4     3
    *
    * 1. Получение широты и долготы пользователя
    * 2. Запрос к БД на получение всех отделений
    * 2.1. Фильтр по отделениям в радиусе пользователя (по широте и долготе)
    * 2.1.1. Если таковых отделений нет, увеличиваем радиус, согласно правилу [>1]
    * 2.2. Фильтр отделений по текущему времени и времени работы
    * 2.2.1. Если таковых отделений нет, увеличиваем радиус, согласно правилу [>2] {оптимизация}
    * 2.3. [список всех работающих отделений в радиусе [>2.1]]
    * 2.4. Функциональная фильтрация отделений, согласно задаваемым пользователем фильтрам
    * 2.4.1. Если таковых отделений нет, увеличиваем радиус, согласно правилу [>1]
    * 2.5. [список отделений, подходящих пользователю по критериям фильтрации]
    * 2.6. Фильтр отделений по правилу загруженности [>3]
    * 2.6.1. Сохранение всех отделений, выполняющих условия выше
    * 2.6.1.1. Статический массив {оптимизация} {memory;count}
    * 2.6.2. Если таковых отделений нет, сохраняем ближайшее отделение [>2.4], увеличиваем радиус
    */
    
*Резюмируя вышесказанное*

Алгоритм изначально уменьшает выборку, посредством сокращения отделений с помощью радиуса, который является расстоянием, которые вычисляются по формуле Haversine,
таким образом удается добиться некоторой оптимизации. Далее алгоритм продолжает уменьшать кол-во отделений с помощью правила приоритета (указано выше, после [4]),
почему это правило выполняется, описывается в датасете правдивости. После основных требований к ближайшему офису, алгоритм сортирует функциональные требования пользователя,
то есть фильтрация отделений по флагам. Существует две версии алгоритма: первая возвращает только один самый выгодный офис, а второй возращает все отфильтрованные офисы
в радиусе, отсортированные по возрастание коэф., зависящего от дистанции и загруженности.

### Откуда брать данные?
Любые операции, происходящие в конкретном отделении банка могут проходить через данный сервис, соответственно, сервис сможет вести статистику и автоматически обновлять данные status
в таблице office.
Например, открытие талона пользователем в отделении и последующее его закрытие. Эти данные сможет отслеживать нас сервис и предпринимать соответствующие действия по обновлению
workload и status
